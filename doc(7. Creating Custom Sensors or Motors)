UNIVERSIDADE FEDERAL DO RIO GRANDE
FARSA - MARXBOT CLEANING EXPERIMENT
RELATÓRIO SEMANAL

	-Alguns sensores executam um pré-processamento dos dados que são extraidos de um sensor físico(Abstraem a imterpretação de dados não digitais).
	-também pode-se implementar uma nova versão de um sensor existente que pré-processe as informações sensoriais de uma maneira diferente em 
	 relação aos sensores existentes.
	-Na pratica (em código) cada sensor atualiza o estado de um certo número de unidades sensoriais ou neurônios sensoriais.
	-Na pratica (em código) cada motor atualiza o estado de um ou mais atuadores do robô com base no estado de uma ou mais unidades 
	 ou neurônios motores do controlador do robô.
	-A interface entre os sensores e motores e os controladores dos robôs é tratada pelo NeuronsIterator class.
	-As unidades sensoriais e motoras são divididas em blocos com o mesmo nome do sensor usado para atualizá-los ou do motor que os 
	 utiliza para definir o estado dos atuadores do robô correspondentes
	-A classe NeuronsIterator inclui as seguintes funções:
		setCurrentBlock() - seleciona o bloco a ser lido ou gravado;
		setInput() - define o valor do elemento atual;
		getOutput() - lê o valor do elemento atual;
		setGraphicProperties() - define as propriedades gráficas do elemento que são usadas pela interface gráfica;
		nextNeuron() - define a próxima unidade do bloco atual.
	
	-Sensores e motores são componentes que podem ser implementados dentro de um plug-in experimental compilado de forma independente da FARSA. 
	 Como todos os componentes implementados em um plug-in, eles devem usar as macros FARSA_PLUGIN_ * e FARSA_REGISTER_CLASS.
	-Sensores que podem ser usados por diferentes tipos de robos são declarados como subclasses da classe geral de sensores (Sensor class), 
	 sensores especificos são declarados em subclasses especificas(nomeadas: KheperaSensor, EpuckSensor, MarXbotSensor e iCubSensor).
	 	-O mesmo vale para motores (nomeados: KheperaMotor, EpuckMotor, MarXbotMotor e iCubMotor).
	-Podemos declarar um Sensor simples da classe geral de sensores (pode ser usado em qualquer tipo de robo) da seguinte maneira:
		class FARSA_PLUGIN_API MinimalSensor : public Sensor
		{
			FARSA_REGISTER_CLASS(Sensor)
		public:
			MinimalSensor(ConfigurationParameters& params, QString prefix);
			~MinimalSensor();
			virtual void save(ConfigurationParameters& params, QString prefix);
			static void describe(QString type);
			virtual void update();
			virtual int size();
		protected:
			virtual void resourceChanged(QString resourceName, ResourceChangeType changeType);
			const QString m_neuronsIteratorResource;
			NeuronsIterator* m_neuronsIterator;
		};

	-A classe Sensor (assim como Motor) herda de ParameterSettableInConstructor. Isso significa que o construtor precisa usar dois parâmetros 
	 e que a função "describe()" deve estar presente. O único parâmetro de configuração que essa classe espera é o nome do recurso do 
	 neuronsIterator (na maioria dos casos, esse parâmetro não precisa ser alterado).
	-definição do sensor(em código):
		void MinimalSensor::describe(QString type)
		{
			// Calling parent function
			Sensor::describe(type);

			// Describing our parameters
			Descriptor d = addTypeDescription(type, "It simply set 3 sensory units to 0.5", "This is an exemplificative sensor that create three sensory units and simply set them to a costant 0.5 value every time");
			d.describeString("neuronsIterator").def("neuronsIterator").help("The name of the resource associated with the neural network iterator (default is \"neuronsIterator\")");
		}
	-Quando o sensor criado será usaddo por um expe5rimento com mais de um robo, o sensor deve se referir ao robo especifico do grupo, 
	 isso é feito pela função actualResourceNameForMultirobot(), que pega o nome do recurso genérico e retorna o nome que o sensor deve usar.
	 exemplo (em código):
	 	MinimalSensor::MinimalSensor(ConfigurationParameters& params, QString prefix) :
			Sensor(params, prefix), m_neuronsIteratorResource(actualResourceNameForMultirobot(ConfigurationHelper::getString(params, prefix + "neuronsIterator", "neuronsIterator"))), m_neuronsIterator(NULL){
				addUsableResource(m_neuronsIteratorResource);
			}

		MinimalSensor::~MinimalSensor(){
		}

	-A função size() retorna quantas unidades do sensor será utilizado(este valor deve ser constante durante a vida útil do sensor)
		int MinimalSensor::size(){
			return 3;
		}